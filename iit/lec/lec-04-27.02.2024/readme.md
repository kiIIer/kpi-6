# Лекція

МЕЛЬНИК МИХАЙЛО БУЛА АРХІТЕКТУРА ОБЧИСЛЮВАЛЬНИХ СИСТЕМ? Ну саме таке не було, може щось схоже.

Коли говоримо про надійність, то обчислювальні системи з реконфігурацією та використання резервних. Рніше от вони встановлювались на супутники та треба було забезпечити його працездатнсіь, системи були ненадійними та часто виходили з ладу, тоді у військових були засоби радіостанції вони були ненадійними, елементи працювали в формованому режимі, були блокі, стійка, інколи лампові на розі гріві, стоїть блок та велика кількість однакових блоків, він сам виїздив сам, працювала сигналізація, підбігали солдатики, викидували його, брали запасний та вставляли його. Коли система не обслуговувана, використовує зазвичай дублюючу систему, яка може працювати а може не працювати, при чому система дублююча в різних режимах, може бути вимкнена, холодний резерв, може бути увімкренна але не працювати, а може бути працювати паралельно. Коли вона працює вона заносить якісь дані для того щоб система яка буде резервна увімкнулась та почала працювати, щоб вона взяла ті дани, але буде невелика втрата даних. Зараз запитання комусь задама. Ось в нас 2 сисемі працюють паралепльно, одна видає дані, інша не видає, перше питання, як визначити що перша системи вийшла з ладу

КРУШЕЛЬНИЦЬКИЙ? Є? нема. КОЗЛОВА? так, також нема, ЗАПОРОЖЧЕНКО? нема. ГРИГОРЬЄВА? ГЛУХОВ? от глухов має бути має бути але нема. ВІТРУК? фдиащгфидвоарфзщаигфва Так ще раз, вітрук я вас не чую. БУТРІЙ? БУЛАХ? А хто в нас староста в цій групі. Добрий день, так Биков Нікіта, заступник старости, а хто староста? Романенко. А він є? нема. Хто не приходить або приходить але нема, він отримає набагато більше запитань на співбесіді ніж інші, бо треба переконатись що він засвоїв матеріал.

Треба порівнювати результати роботи систем, видають всі, якщо вони не однакові, в одній з системі помилка, тоді ми можемо надати вхідні дані відповідь на яку ми знаємо, тоді дізнаємось хто зробив помилку.

3 задачі, 3 ситеми, ЛАПА. Ну можна вирішити 3 задачі 2 системами. Ну це вже не природній паралелізм. Ми говоримо про властивості задач вони не вз'язані. Ну ці задачі можна виконувати на одному пристрої. Ну от робиться задача та щоб перемикнутись, треба зберегти проміжні результати. От є процесор в нього треба занести збережені результати іншого процесу та тоді запускаємо, тоді в нас будуть витрати таефективність впаде не втричі а трохи більше ніж втричі.

Наступний паралелізм це паралелізм незалежних гілок задачі. От ми визначили гілки в задачі та можемо гілки розраховувати окрема, приклад можете навести, щоб зрозумілий всім було. Можливо аналіз даних ЩО Що ви так ускладнюєте? Ну так взісно ми можемо аналіз даних, ми можемо зробити фільтрацію, потім інший методи фільтрації потім сортування, можу привести приклад але він не вдалий, от виграєтесь в іграшки і у вас образи, от в танки граєтесь і їде кожний такн, от кожен їде та можна кожного розраховувати окремо. От є полігони, кожен танк це окремий полігон і його можна на свою. Тобто якщо є незалежні гілки, їх можна надати на виконання пристроям виконуючим. Так що в нас там... СОФІЯ МЕНДИК Є? єєєєєєєє просто не могла звук включити, так вже перерва. Перерва 5 хвилин

Датчики надають потік даних і їх можна обробляти окремим пристроєм і можна забезпечити оброблення на кожному обролюючому пристої які надходять від окремого обяєкту

Наступний підіхід для підвищення продуктивності, це конвеерна обробка. ТАм є такий на виробництві конвеєр, тут те ж саме, в нас кілька виконуючих пристроїв. Кожен з них робить певну операцію, кожен швидко виконується, і іде до іншого, от в нас етапи є. От перше пи роглядаємо додавання. Зрозуміло що універсальний процесор може зробити все це сам, тобто один за одним, якщо цей час універсальний процесор робить операцію 60, потім 100, потім 140 і 100, якщо знехтуємо накладними расходами, він зробить це за 400 нс. Спеціалізовані процесори можуть робити задачі швидше і може туби ріск архітектура і воно буде текаж все пришвидшувати, будемо думати що в нас спеціалізовані модулі, які роблять операцію та предають далі. Отже час виконання в нас різний і 3 в нас найповільніший, треба встановити пам'ять перед тим що робить довго, щоб перед ним накопичувати дані. В улюдських конвеєрах, типу заводу мередіан, він там збирав прийймачі та обчислення, то там гору таку зробив та хтось прийде там буде робити, але в реальних таке не треба, в реальних роблять простіше, швидкодія системи буде рівна швидкодії найповільнішого подуля, тобто всі умовно будуть однаково робити. Тобто універсальний процесор нам дасть за 400, а в конвеері 140*4 ГАЛАГАН 540, ну виходить що мищось зробити щоб щось покращити, а воно видасть результат повільніше ніж універсальний процесор, ну і навіщо нам таке? Надійним він не буде, чим більше компонентів, тим вона менш надійна, якщо ми створили засіб, пристрій якийсь, і ми додали компоненти контрлю, тобто ми зменшили надійність, бо нові компоненти можуть вийти з ладу. Тобто додавання компонентів та блокі можуть вийти через них. А от блокі універсальні і буде дороще ніж універсальний, бо універсальний дасть через 400, а конвеер через 560, тобто ми почали з того що конвеер пришвидшує а насправді ні.

Якщо ми будмо робити універсальним кожне бути через 400, а якщо конвеером, ми отримаємо перший результат череез 560, але наступний буде вже через 140. І виграш буде тим більше тим більше послідовність даних. Зрозуміло? Для одного результату то недоцільно, але якщо ми робимо вектор, в них багато даних які надходять послідовно, і спочатку обчислює перший, далі він обичислює нові, а другий тільки отримав попередні, і ми потім будемо кожен такт отримувати дані. Зрозуміло? Тому якщо в нас буде ми з вами розраховуємо на якусь велику кількість даних ну от наприклад в нас 25 елементів цим конвеером, то універсальний буде 10000 наносекунд. а той буде за 3920. Тобто чим більше в нас буде етапів розбити, то тим більше буде переваг від конвеера. І коли ми робимо якісь розрахунки то в нас будуть вектора та всі такі дані які треба обробити.

Далі це конвеєр команд. Тут я взяв 6 таких операцій. Тут так само етапи та ось виконання цих етапів. Що ми тут бачимо? Зараз... Бачимо що в нас ну лічильні команди. Тобто є якийсь лічильник команд, постійно інкремент, зчитав першу команду, додав кодиничку, зчитав другу, і так він рухається типу команда нема операції. На рівні операційної системи, на рівні компіляторів ці задачі  також вирішуються, перше це визначаємо адресукоманди, далі вибрали команду з пам'яті, розшифровка коду операції, формування адрес операндів, вибір операндів з пам'яті, завантаження їх в логічний пристрій, і якщо процесор універсальний там зробив це, зробив це, і ці операції кудись їх сховав і так працює процесор без конвеєра команд, швидкодія буде менла. В конвеєрі команд це все розбито на етапи, на першому ми вибириємо адрусу, на другому ми вже передали адресу, та почали брати нову адресу. І за 6 тактів буде вже це робити. А якщо не було конвеєру команд, то ми раз у ш6 тактів отримували, а так ми 6 тактів запускаємось.

І конвеєр команд працював би нормально, але якщо в нас є умовний переход, якщо він відбувся, в 90% він відбудеться знову, ми можемо дані не викидати, бо може ми повернемось, ось в нас 5рівневий конвеєр і ось в нас отримання інструкцій, розкодування інструкцій, це таке сучасне представлення  снструкцій. В не ріск там є команди які за кілька тактів виконуються, а є команди з умовно косвеною адресацією, можуть бути 26 тактів, і тут також можуть бути швидкість виконання наскільки швидко кожна виконується і наскількиетапів ми розбили і коли в програмах не буде умовних якихось переходів, якщо не умовинй то як звичайно, а якщо перехід, то в нас скидається конвеєр.

Окрім того там зрозуміло що в в системаї є і конвеєр команд, і ще там щсь. Буде краще якщо в нас суперскалярний процесор, якщо в нас багаато модулів виконання і можуть робити октемі операціх. типу арифметикологічні операції, з фіксованою комою, і от вони знаходяться.

ЗАСЛАВСЬКИЙ? немає. ЗАХАРЧУК? да скільки отримав? Дві? Ні, кожен з них. Є 2 потоки, це команд і даних, кожен може бути або одиночним або множинним, ну от да він отримав 4 системи. Мається на увазі що множинний поток команд, це бгато послідовностей команд. З цим ми розбірлись коли процесор викониє дані.

От ну і в ситсеми, ось 4 ці системц, зазвичай виконистовується англ. Система з одиночним/множинним потоком команд і одиночним/множинним потоком даних. Зрозуміло?

ТАк що в нас СОФІЯ скільки ще часу? Ще 5 хвилин є. Почекайте, як 5 хвилин? В нас в 12. Взагалі в 11 55 закінчується. Ну тоді поговоримо.

перша система одиночний потік команд, система класу ОКОД, от в нас є дані команд які зберігаються в запам'ятовуючому пристрої, сюди надходять пристрої дешифрування, я запам'ятовуючий пристрій даних, в арифметико логічному вони обробляються. Данні зчитались, обробились і знову в пам'ять.

Такі сифтсеми будуються за 2 структурами, це орхітектура фон неймана та гарвардська. І той і той виконує свої принципи. Ну воно так прийнято фон неймана, що там легенда та придумав таку геніальну таку схему, геніальність в тому що тут є одна шина і шина даних де читуються і команди і дані. І це вся геніальність. Плюси що менше дротів та доріжок, але пам'ять одна можемо або до цієї або до ціє. Гарвардська там є своя шина даних і є своя в команд. Якщо 86 процесор там за архітектурою фон неймана, там є адресна шина і вона мультиплексована з шиною даних. За цими шинами або зчитування або запис даних на вхід або вихід процесора. 86 він доволі потужний скільки в нього розрядкість 20. А шина даних 16 розрядка, якщо їх окермо треба 36 контактів, а так всього 20, тобто відбувається мультиплексування, зменшуємо розміри процесора, але це впливає на швидкодію, оскільки в гарвардський можемо ордару 2 адреси виставляти. Це такі 2 основні архітектури, ну от вони і основні пов'язані зі зверненнями.
